{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
<main class="main"> 
    <h1>Report</h1>
    <div class="two-col-layout">
        <aside class="aside">
            <ul>
                <li><a href="#kmom01">kmom01</a></li>
                <li><a href="#kmom02">kmom02</a></li>
                <li><a href="#kmom03">kmom03</a></li>
                <li><a href="#kmom04">kmom04</a></li>
                <li><a href="#kmom05">kmom05</a></li>
                <li><a href="#kmom06">kmom06</a></li>
                <li><a href="#kmom10">kmom10</a></li>
            </ul>
        </aside>
        <article class="article">

            <h2 id="kmom01">kmom01</h2>
            <p class="author"></p>
            <p class="author">Första gången jag kom i kontakt med objektorienterad programmering var i Python kursen som gick tidigare denna termin. Vi fick lära oss grunderna genom att programmera ett yahtzee spel med klasser för tärningar, spelhand och spelregler. Koncept som abstrakt klass och arv användes flitigt.</p>

            <p class="author">Det går att dela upp processen att förstå PHPs modell för klasser och objekt i två delar:
            <ol><li>Allmän insikt. Här hjälper tidigare erfarenhet av objektorienterad programmering i andra språk. Du behöver förstå grunderna såsom att klasser är ett sätt att organisera data/variabler och funktionalitet/kod tillsammans på en plats. På så vis kan vi fokusera på datatypen först, och anpassa funktionaliteten därefter.</li><li>Specifik insikt. PHP följer sin egen syntax och därmed behöver vi även känna till denna.</li></ol></p>

            <p class="author">Jag känner mig fortfarande inte särskilt familjär med kodbasen vi använder i Symfony, eftersom allt är så pass nytt. Just CSS och hur denna skall organiseras är det jag haft allra svårast för. Jag försökte implementera samma struktur som i webtec kursen men kunse inte länka till andra css-filer i ‘app.css’. Vet inte vad best practice är, om jag ska länka till flera css-filer i ‘app.js’ och ‘base-twig’ eller lösa det på annat sätt genom att implementera en CSS-template…</p>

            <p class="author">I artikeln “PHP The Right Way” upplever jag att det finns mycket användbar information eftersom den är skriven på rätt nivå för mig, dvs. utmanande men inte omöjlig att ta till sig. Särskilt avsnitten där jag besitter lite kunskap såsom databases, templating, language highlights och testing var intressanta  att läsa om översiktligt. ‘Test driven development’ verkar häftigt. Det får bli en prioritet att sätta mig in i många av artiklens underkapitel mer på djupet.</p>

            <p class="author">TIL att det finns en enorm potential fördel och även komplexitet med ramverk som Symfony i kombination med diverse Composer installerade paket. Flexibiliteten är hög och jag är nyfiken på i vilken grad denna typ av programmering kan bli mer ‘applicerad’ i sin natur med färdiga lösningar dvs. mer implementering av färdiga program än nyskrivna egna lösningar. I  ekonometri kan data analyseras med hjälp av färdiga program och det handlar mycket om att välja ut vilka analyser som bör göras snarare än att utveckla nya. I vilken utsträckning blir detta fallet även inom programmering då ramverken blir allt mer avancerade?</p>


            <h2 id="kmom02">kmom02</h2>
                <p>Arv är en objektorienterad konstruktion som tillåter oss att skapa nya klasser med samma data och funktionalitet (variabler och metoder) som dess basklass. Detta förutsätter att allt ligger under en publik eller skyddad API i basklassen, privata variabler och metoder ärvs ej.</p>
                <p>Det finns inte multipelt arv i PHP.  Ett alternativ till detta är att använda interface och/eller traits, som båda är objektorienterade konstruktioner i PHP. Interfaces är ett kontrakt med en eller flera klasser där ett antal publika metoder specificeras i interface, utan kod, som sedan måste implementeras i klasserna. Dessa metoder kan sparas i traits. Detta ger oss ett sätt att skapa mer 'DRY'-kod, genom att spara metoder som behöver återanvändas i traits.</p>
                <p>Komposition är inte ett sätt att återanvända eller specialisera kod genom en PHP konstruktion. Istället är det något som är nödvändigt inom all OOP då en klass behöver använda sig av en annan klass. Det vill säga då sambandet är av typen ‘har’, och inte ‘är’.</p>
                <p>TIL användbarheten av att kopiera och kommentera ut kod istället för att skriva om den direkt vid större förändringar. Med ett verktyg som git  är detta säkert smidigt kan jag tänka mig. Poängen är att det är smidigt att ha något att kolla tillbaka på och felsöka med då man befinner sig i träsket och försöker implementera en ny lösning som kanske ska göra exakt samma som föregående lösning men på ett bättre sätt. Detta var fallet då jag skrev om mina klasser så att de fick ‘card’-klassen ‘injected’ via argument istället för att skapa dem som objekt inuti ‘ägar’ klassen.</p>
                <p>Jag gillar Symfony. Det är lätt att känna sig överväldigad av alla nya termer och sätt att strukturera filerna. Jag kan dock redan se hur det finns stor potential för att bygga en välorganiserad applikation med hjälp av applikations/metod-klasser (svengelska?). Behovet att detta blir säkerligen större ju mer kod/fler utvecklare som är involverade Dessutom kan jag föreställa mig stor flexibilitet i hur olika paket med composer kan implementeras.</p>

            <h2 id="kmom03">kmom03</h2>
            <p>Jag uppskattar flowcharts i problemlösnings processen. Det gav mig överblick av problemet och gjorde det tydligt när en händelse eller process behöver ske. Jag kände ett det var till hjälp då jag skulle fundera och designa mina modellklasser. Det jag i ärlighetens namn inte hade särskilt mycket hjälp av var pseudokod. Detta kan dock bero på att det blev lite för hög detaljnivå för tidigt, kombinerat med att det var ett helt nytt sätt att skriva kod på. Med mer erfarenhet kan jag tänka mig att verktyget blir bättre. Tror dock såhär efter att ha använt det en gång att vi behöver ha hyfsat bra förståelse för problemen innan vi kan implementera pseudokod. Detta kanske dock är sant för alla typer av problemlösningsplaner vi gör... förstå problemet så bra du bara kan först!</p>
            <p>Löste problemet genom att implementera en 'Player' och en 'PlayerBank' klass som ärver från Player och har lite annan funktionalitet men samma medlemsvariabler. Förbättringspotential finns definitivt. Exempelvis borde vi göra views lite dummare, det finns lite väl mycket logik där i nuläget. Skulle även kunna implementera mer interface+trait istället för arv för att göra koden mer testbar och bidra till enklare framtida vidare utveckling. </p>
            <p>Heja Symphony! Tycker det funkar super bra med composer och npm. Väldigt välorganiserad och super kraftfull, så många valmöjligheter.</p>
            <p>TIL dela upp större problem i mindre och ta din promenad så ska du se att allt går fina fisken!</p>

            <h2 id="kmom04">kmom04</h2>
            <p>Jag tycker PHPunit liknar unittest från python kursen. Många konstruktioner såsom setup, teardown, och assert är samma bortsett från lite annorlunda syntax. Det som skilde var att jag i PHPunit jobbade mycket mer med setters och getters. Jag upptäckte att det gick att komma åt privata attribute även med PHPunit men har tolkat det som att det är bäst practice att undvika detta när det är möjligt. Vi vill testa det publika APIet samt hur denna jobbar eftersom det är detta som är relevant vid implementation av vårt system/program. Jag tycker manualen till PHPunit är välskriven och hyfsat lätt att hitta runt i även för en nybörjare som mig själv.</p>
            <p>Jag uppnådde 90% på de flesta av mina testobjekt, slöade mig på sista. Jag uppfattar dock att det blev många 'positive cases' vid min testning. Kan definitivt se att mina asserts skulle kunna hålla bättre kvalite, testa edge cases bättre exempelvis. När vi har hög kod täckning som huvudmål blir det lätt att vi testar enklast möjliga cases.</p>
            <p>Jag tycker min kod var testbar eftersom beroendena mellan objekten (kort/hand/deck och hand/player) sköts med 'dependency injection'. Detta medför att vi kan använda stubs för att representera objekten som injekterats, varpå vi kan skapa tester som är oberoende av att andra klasser är buggfria. Ett beroende jag dock har är det mellan metoderna som testas. Ibland kallar jag på andra metoder inom klassen och här finns det därmed ett beroende. Även då jag vill arbeta med privata attribute är jag beroende av att använda setter och getter metoder. Alternativet skulle vara att använda de private attributen direkt, vilket var så vi fick jobba i python kursen. Där använda vi även 'seed' för att låsa randomiseringar, samt skapade attributen genom att manipulera dem direkt i setup-funktionen (arange-fasen) istället för att använda en 'constructor'. På så vis togs beroendet av setters och getters bort, men vi jobbar direkt mot attributen någon som kanske inte är best practice. Jag är lite osäker på vilket arbetssätt som är bäst vid testning.</p>
            <p>Jag behövde inte skriva om min kod för att kunna testa den. Jag tycker skapandet av stubs var mycket smidigt. Jag tror det finns mycket överlapp mellan att skriva 'SOLID'-kod som följer 'MVC'-principer(stora modeller, dumma views och små controllers), med att skriva kod som är enkel att testa. Om vi gör våra funktioner små med en uppgift, där sidoeffekterna är begränsade och sambandet mellan input och output är tydligt kommer det många gånger vara smidigt att testa dem. Detta är ofta fallet då vi lägger vår logik i modell-klasser och använder SOLID-kod.</p>
            <p>TIL skillnaderna mellan PHPunit och unittest-Python, samt att det är mycket användbart att i lärande processen jämföra nya kunskaper med gamla.</p>

            <h2 id="kmom05">kmom05</h2>
            <p>Övningen gav en bra introduktion till doctrine. Jag reagerade på hur mycket som var automatiserat vid skapandet av ‘migration’, ‘entity’ och ‘controller’. Detta gjorde processen att komma igång med ORM i SQLite mycket smidig. Hade önskat att övning beskrev hur BLOB resources kan sparas och användas i SQLite med ORM eftersom detta var mycket krångligt för mig att förstå. Har fortfarande ingen aning om 'best practice' i hur vi jobbar med dessa.<p\>
            <p>Jag valde att bygga min applikation utifrån CRUD i databaskursen. Detta gav mig tillgång till forms och tables med relevant CSS- styling. Det var även en smidig lösning med GET och POST routes, och hur de länkas samman. Jag lade till en meny till vänster som alltid syns för att göra användarupplevelsen top notch 👏.<p\>
            <p>ORM gick bra för de relativt enkla konstruktioner som CRUD kräver. Jag är definitivt i nuläget mer bekväm med SQL i allmänhet. Skulle behöva leta ordentligt i manualen om jag skulle vilja återskapa allt vi gjorde i databas kursen i ORM! Kan se att den lönar sig att kunna båda. Förståelse inom endera området gör det andra mindre ‘magiskt’. Det går att förstå och förutspå ungefär hur saker borde funka inom ORM även om syntaxen är ny då vi kan SQL, i alla fall vid enklare användning.<p\>
            <p>ORM gör det enkelt att arbeta med ett objektorienterat tänkesätt. Jag kan se hur detta kan vara en stor fördel jämfört med annan applikationsskod då vi vill spara properties i databasen! Ser även stor potential i att spara funktioner i klasserna som hanterar mer avancerade SQL-queries, som att hitta vissa rader i databasen baserat på vissa egenskaper. Detta ger oss även fin inkapsling, data och tillhörande funktioner sparas tillsammans. <p\>
            <p>TIL att olika programmeringsspråk och tillhörande verktyg kan kompletterar varandra mycket väl. Twig och ejs samt symphony och ren express.js har väldigt många konceptuella likheter. Vi har stor nytta av kompletterande kunskap och erfarenheter! <p\>


            <h2 id="kmom06">kmom06</h2>
                <p>I Phpmetrics var bilder och mätvärden på cohesion och complexity särskilt användbara i min analys. De gav bra återkoppling på när metoder och klasser behöver skrivas om. Jag tenderar att göra ganska komplexa kontrollklasser.</p>
                <p>Integreringen med Scrutinizer krånglade initialt. Felkoden nämnde att npm versionen inte passade med min composer lock. Det löste sig efter att jag ändrat vald php version i config filen till 8.2. Detta är en nyare version än vad som stod där innan. Jag får en bra känsla av högt betyg på 'badges', så lite motiverande är det nog allt! Betyg efter första bygget var 9.93 med 29.05% kod täckning. Detta inkluderar vissa externa klasser skapade vid ORM, och även kontrollklasser.</p>
                <p>Visst tror jag höga badge betyg indikerar en högre kodkvalitet i snitt. Om vi jämförde 1000 github repo och delade in dem i grupper med höga respektive låga betyg kommer kvaliteten tendera att vara bättre i hög betygsgruppen. Delvis för att repon med höga betyg antagligen brytt sig om att kolla en gång extra på koden och fixad enhetstester. Min hypotes är dock att det kan finnas stora individuella skillnader. Vissa arbetsgrupper kanske skriver avancerade och omfattande enhetstester som kollar på edge cases bara där det verkligen behövs. Och de kanske har en bra anledning till varför de föredrar långa och komplexa klasser eller metoder. </p>
                <p>TIL att det går att göra fina skärmdumpar på exakt det vi vill ha och spara som bilder med hjälp av verktyg i firefox. Borta är dagarna då vi behöver beskära skärmdumpar manuellt.</p>

            <h2 id="kmom10">kmom10</h2>
            <p>Jag valde att implementera spelet Black Jack. Metodklasserna BlackJackPlayer och BlackJackDealer tillät mig skapa objekt som kan agera spelare och bank inom detta spel. Skillnaden mot kortspelet 21 var att korten var värderade annorlunda och hur spelaren vinner skiljer sig också. Dessutom finns en Black Jack regel. Detta implementerade jag i metodklasserna, som ärvde från Player och seden tillfördes funktionaliteten som krävdes. Mycket av det som skulle göras i krav 'Repo och Dokumentation' var redan avklarat från tidigare kursmoment. Jag skrev till enhetstester för de nya metod-klasserna och någon mening i README.  </p>
            <p>Projektet gick bra att genomföra. Spenderade kanske 20 timmar totalt. Vissa delar såsom att skriva logiken för BlackJack-regeln tog lite tid. Valde att prioritera att göra 'view' det vill säga mina templates lite dummare genom att inkludera många av dem liknande varandra. Sedan kunde logik i controler-klasserna skicka till rätt template. Ett alternativ hade varit att skriva en avancerad template med if-satser. Detta skulle dock resultera i smartare views.</p>
            <p>Jag är nöjd med kursen och känner att allt vi gjort följt en röd tråd, precis som andra kurser ni tillhandahåller. Eftersom att mina kmoms har kommit in så pass sporadiskt och ni har många studenter kan jag inte förvänta mig utförlig personlig feedback vilket jag är väl medveten om. Dessutom ligger det på mig att tillgodose mig kunskapen som krävs för att bli en bra webbutvecklare och jag tycker (i min eventuella okunskap) att resurserna ni tillhandahåller är av hög kvalitet. Att arbeta och lösa problem självständigt är definitivt en bra förmåga att utveckla. Video föreläsningarna var nyttiga och lite småroliga som vanligt! Betyg 9/10.</p>
            <p></p>
            <p></p>
            <p></p>
            <p></p>
            <p></p>
            <p></p>
        </article>
    </div>
</main>
{% endblock %}
