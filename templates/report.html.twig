{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
<main class="main"> 
    <h1>Report</h1>
    <div class="two-col-layout">
        <aside class="aside">
            <ul>
                <li><a href="#kmom01">kmom01</a></li>
                <li><a href="#kmom02">kmom02</a></li>
                <li><a href="#kmom03">kmom03</a></li>
                <li><a href="#kmom04">kmom04</a></li>
                <li><a href="#kmom05">kmom05</a></li>
                <li><a href="#kmom06">kmom06</a></li>
                <li><a href="#kmom10">kmom10</a></li>
            </ul>
        </aside>
        <article class="article">

            <h2 id="kmom01">kmom01</h2>
            <p class="author"></p>
            <p class="author">Första gången jag kom i kontakt med objektorienterad programmering var i Python kursen som gick tidigare denna termin. Vi fick lära oss grunderna genom att programmera ett yahtzee spel med klasser för tärningar, spelhand och spelregler. Koncept som abstrakt klass och arv användes flitigt.</p>

            <p class="author">Det går att dela upp processen att förstå PHPs modell för klasser och objekt i två delar:
            <ol><li>Allmän insikt. Här hjälper tidigare erfarenhet av objektorienterad programmering i andra språk. Du behöver förstå grunderna såsom att klasser är ett sätt att organisera data/variabler och funktionalitet/kod tillsammans på en plats. På så vis kan vi fokusera på datatypen först, och anpassa funktionaliteten därefter.</li><li>Specifik insikt. PHP följer sin egen syntax och därmed behöver vi även känna till denna.</li></ol></p>

            <p class="author">Jag känner mig fortfarande inte särskilt familjär med kodbasen vi använder i Symfony, eftersom allt är så pass nytt. Just CSS och hur denna skall organiseras är det jag haft allra svårast för. Jag försökte implementera samma struktur som i webtec kursen men kunse inte länka till andra css-filer i ‘app.css’. Vet inte vad best practice är, om jag ska länka till flera css-filer i ‘app.js’ och ‘base-twig’ eller lösa det på annat sätt genom att implementera en CSS-template…</p>

            <p class="author">I artikeln “PHP The Right Way” upplever jag att det finns mycket användbar information eftersom den är skriven på rätt nivå för mig, dvs. utmanande men inte omöjlig att ta till sig. Särskilt avsnitten där jag besitter lite kunskap såsom databases, templating, language highlights och testing var intressanta  att läsa om översiktligt. ‘Test driven development’ verkar häftigt. Det får bli en prioritet att sätta mig in i många av artiklens underkapitel mer på djupet.</p>

            <p class="author">TIL att det finns en enorm potential fördel och även komplexitet med ramverk som Symfony i kombination med diverse Composer installerade paket. Flexibiliteten är hög och jag är nyfiken på i vilken grad denna typ av programmering kan bli mer ‘applicerad’ i sin natur med färdiga lösningar dvs. mer implementering av färdiga program än nyskrivna egna lösningar. I  ekonometri kan data analyseras med hjälp av färdiga program och det handlar mycket om att välja ut vilka analyser som bör göras snarare än att utveckla nya. I vilken utsträckning blir detta fallet även inom programmering då ramverken blir allt mer avancerade?</p>


            <h2 id="kmom02">kmom02</h2>
                <p>Arv är en objektorienterad konstruktion som tillåter oss att skapa nya klasser med samma data och funktionalitet (variabler och metoder) som dess basklass. Detta förutsätter att allt ligger under en publik eller skyddad API i basklassen, privata variabler och metoder ärvs ej.</p>
                <p>Det finns inte multipelt arv i PHP.  Ett alternativ till detta är att använda interface och/eller traits, som båda är objektorienterade konstruktioner i PHP. Interfaces är ett kontrakt med en eller flera klasser där ett antal publika metoder specificeras i interface, utan kod, som sedan måste implementeras i klasserna. Dessa metoder kan sparas i traits. Detta ger oss ett sätt att skapa mer 'DRY'-kod, genom att spara metoder som behöver återanvändas i traits.</p>
                <p>Komposition är inte ett sätt att återanvända eller specialisera kod genom en PHP konstruktion. Istället är det något som är nödvändigt inom all OOP då en klass behöver använda sig av en annan klass. Det vill säga då sambandet är av typen ‘har’, och inte ‘är’.</p>
                <p>TIL användbarheten av att kopiera och kommentera ut kod istället för att skriva om den direkt vid större förändringar. Med ett verktyg som git  är detta säkert smidigt kan jag tänka mig. Poängen är att det är smidigt att ha något att kolla tillbaka på och felsöka med då man befinner sig i träsket och försöker implementera en ny lösning som kanske ska göra exakt samma som föregående lösning men på ett bättre sätt. Detta var fallet då jag skrev om mina klasser så att de fick ‘card’-klassen ‘injected’ via argument istället för att skapa dem som objekt inuti ‘ägar’ klassen.</p>
                <p>Jag gillar Symfony. Det är lätt att känna sig överväldigad av alla nya termer och sätt att strukturera filerna. Jag kan dock redan se hur det finns stor potential för att bygga en välorganiserad applikation med hjälp av applikations/metod-klasser (svengelska?). Behovet att detta blir säkerligen större ju mer kod/fler utvecklare som är involverade Dessutom kan jag föreställa mig stor flexibilitet i hur olika paket med composer kan implementeras.</p>

            <h2 id="kmom03">kmom03</h2>
            <p>Jag uppskattar flowcharts i problemlösnings processen. Det gav mig överblick av problemet och gjorde det tydligt när en händelse eller process behöver ske. Jag kände ett det var till hjälp då jag skulle fundera och designa mina modellklasser. Det jag i ärlighetens namn inte hade särskilt mycket hjälp av var pseudokod. Detta kan dock bero på att det blev lite för hög detaljnivå för tidigt, kombinerat med att det var ett helt nytt sätt att skriva kod på. Med mer erfarenhet kan jag tänka mig att verktyget blir bättre. Tror dock såhär efter att ha använt det en gång att vi behöver ha hyfsat bra förståelse för problemen innan vi kan implementera pseudokod. Detta kanske dock är sant för alla typer av problemlösningsplaner vi gör... förstå problemet så bra du bara kan först!</p>
            <p>Löste problemet genom att implementera en 'Player' och en 'PlayerBank' klass som ärver från Player och har lite annan funktionalitet men samma medlemsvariabler. Förbättringspotential finns definitivt. Exempelvis borde vi göra views lite dummare, det finns lite väl mycket logik där i nuläget. Skulle även kunna implementera mer interface+trait istället för arv för att göra koden mer testbar och bidra till enklare framtida vidare utveckling. </p>
            <p>Heja Symphony! Tycker det funkar super bra med composer och npm. Väldigt välorganiserad och super kraftfull, så många valmöjligheter.</p>
            <p>TIL dela upp större problem i mindre och ta din promenad så ska du se att allt går fina fisken!</p>

            <h2 id="kmom04">kmom04</h2>
            <p>Jag tycker PHPunit liknar unittest från python kursen. Många konstruktioner såsom setup, teardown, och assert är samma bortsett från lite annorlunda syntax. Det som skilde var att jag i PHPunit jobbade mycket mer med setters och getters. Jag upptäckte att det gick att komma åt privata attribute även med PHPunit men har tolkat det som att det är bäst practice att undvika detta när det är möjligt. Vi vill testa det publika APIet samt hur denna jobbar eftersom det är detta som är relevant vid implementation av vårt system/program. Jag tycker manualen till PHPunit är välskriven och hyfsat lätt att hitta runt i även för en nybörjare som mig själv.</p>
            <p>Jag uppnådde 90% på de flesta av mina testobjekt, slöade mig på sista. Jag uppfattar dock att det blev många 'positive cases' vid min testning. Kan definitivt se att mina asserts skulle kunna hålla bättre kvalite, testa edge cases bättre exempelvis. När vi har hög kodtäckning som huvudmål blir det lätt att vi testar enklast möjliga cases.</p>
            <p>Jag tycker min kod var testbar eftersom beroendena mellan objekten (kort/hand/deck och hand/player) sköts med 'dependency injection'. Detta medför att vi kan använda stubs för att representera objekten som injekterats, varpå vi kan skapa tester som är oberoende av att andra klasser är buggfria. Ett beroende jag dock har är det mellan metoderna som testas. Ibland kallar jag på andra metoder inom klassen och här finns det därmed ett beroende. Även då jag vill arbeta med privata attribute är jag beroende av att använda setter och getter metoder. Alternativet skulle vara att använda de private attributen direkt, vilket var så vi fick jobba i python kursen. Där använda vi även 'seed' för att låsa randomiseringar, samt skapade attributen genom att manipulera dem direkt i setup-funktionen (arange-fasen) istället för att använda en 'constructor'. På så vis togs beroendet av setters och getters bort, men vi jobbar direkt mot attributen någon som kanske inte är best practice. Jag är lite osäker på vilket arbetssätt som är bäst vid testning.</p>
            <p>Jag behövde inte skriva om min kod för att kunna testa den. Jag tycker skapandet av stubs var mycket smidigt. Jag tror det finns mycket överlapp mellan att skriva 'SOLID'-kod som följer 'MVC'-principer(stora modeller, dumma views och små controllers), med att skriva kod som är enkel att testa. Om vi gör våra funktioner små med en uppgift, där sidoeffekterna är begränsade och sambandet mellan input och output är tydligt kommer det många gånger vara smidigt att testa dem. Detta är ofta fallet då vi lägger vår logik i modell-klasser och använder SOLID-kod.</p>
            <p>TIL skillnaderna mellan PHPunit och unittest-Python, samt att det är mycket användbart att i lärande processen jämföra nya kunskaper med gamla.</p>

            <h2 id="kmom05">kmom05</h2>
            <p></p>
            <p></p>
            <p></p>
            <p></p>

            <h2 id="kmom06">kmom06</h2>
            <p></p>
            <p></p>
            <p></p>
            <p></p>

            <h2 id="kmom10">kmom10</h2>
            <p></p>
            <p></p>
            <p></p>
            <p></p>
        </article>
    </div>
</main>
{% endblock %}
